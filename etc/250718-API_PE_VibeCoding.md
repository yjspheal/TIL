# 교육 자료

[14기_0716_SW_AI 스타트캠프_파이썬트랙_Day3](https://edu.ssafy.com/data/upload_files/crossUpload/openLrn/ebook/unzip/A2025071517563141500/index.html)

# ChatGPT

- Generated Pretrained Transformer
- GPT 모델을 기반으로 한 대화형 AI

## 주요 개념

- Generated
  - 기존 패턴을 기반으로 새로운 콘텐츠를 생성
- Pretrained
  - 거대 언어모델 + 추가 학습 데이터 + 추가 강화 학습
- Transformer
  - 문장 속의 단어 간 관계를 추적해 맥락과 의미를 학습
  - 인간처럼 일관되고 연관성이 높은 언어를 구사하여 대화형 작업에 강점

## 트랜스포머

- 문장의 맥락을 효과적으로 이해하고 처리하는 attention 메커니즘 사용

### 주요 개념

- self-attention 메커니즘
  - 입력 데이터 간의 관계와 중요도를 계산
- 병렬 처리 가능
  - RNN과 달리 순차 처리가 필요 없어 속도가 빠름
- 스케일링 가능
  - 대규모 데이터 및 파라미터로 확장 가능
- GPT는 Transformer의 디코더 부분만을 사용

---

### 🧲 Attention 메커니즘

- AI가 데이터의 **맥락과 중요도**를 이해하도록 돕는 필수 기술

- 입력 데이터의 각 요소가 출력에 얼마나 중요한지 **중요도(weight)**를 계산하는 기법

- "**중요한 것에 집중한다**"는 아이디어를 바탕으로 설계됨

- 종류
  
  - **Self-Attention**
    
    → 입력 데이터 내부에서 **각 요소 간 중요도**를 계산
  
  - **Multi-Head Attention**
    
    → 다양한 관심사(관점)를 **병렬로 계산**하여 성능 향상

---

# API

## Interface란?

- 서로 다른 두 개의 시스템(기기, 소프트웨어 등)이 정보를 교환할 때 그 사이에 존재하는 접점
- 키보드, 마우스, 모니터 - 컴터 and 사람의 물리적 인터페이스
- 자동차 운전대, 페달 - 차와 사람 사이 인터페이스

### UI

- 사람(유저)이 sw에 접근하는 그래픽적, 화면적 요소
- atm의 선택 화면, 스마트폰 앱의 아이콘 등

**눈에 보이지 않는 영역에서도 수많은 통신이 이루어지고 있다**

## 클라이언트와 서버

### 웹의 동작 방식

- 유저가 네이버를 누름
- 클라이언트: 서버야, 우리 클라이언트가 네이버 홈피에 가고싶대
- 서버: 알았어 여기 페이지랑 데이터 줄게
- 클라이언트: 자 유저야 네이버 홈피 여깄어

### 클라이언트

- 서비스를 요청하는 쪽
  - 유저의 웹브라우저, 모바일앱 등

### 서버

- 요청을 받아서 처리하고, 결과를 응답해주는 쪽
  - 웹 서버, 데이터베이스 서버

## 그래서 API가?

- 두 소프트웨어가 서로 통신할 수 있게 하는 메커니즘
- 약속된 방식의 인터페이스로, 특정 규칙에 따라 데이터를 요청하고 응답하는 규칙을 제공

### Application

- 특정 기능을 수행하는 모든 소프트웨어
  - 웹 모바일 데스크톱 앱 등 우리가 만든 서비스나 프로그램도 모두 앱의 일종

## API 활용

- API 예시 - 소셜 로그인
  - 생판 다른 페이지인데 왜 구글로 회원가입을 시켜주는 거죠?

## API Key

- API에게 요청을 보내는 애플리케이션을 구별하기 위한 고유한 식별 문자열

### key 가 필요한 이유

- 보안 강화
  - 무단 접근을 막고 승인된 사용자만 요청할 수 있도록
- 데이터 관리
  - API호출 횟수, 사용량 모니터링 가능
  - 일정량 이상 사용 시 과금 정책 적용 등

## 주의사항

- 공개된 곳에 노출하지 말 것
- 키가 유출될 경우 무단 사용됨 → 정기 갱신 필요

---

# Prompt Engineering

### 🔸 토큰 (Token)

- GPT 모델은 **텍스트 데이터를 처리하고 이해할 때 '토큰' 단위**로 작동함

- **토큰 = 단어 또는 단어 조각**
  
  → 각 토큰에는 고유한 숫자가 매겨짐

- 영어보다 **한글 문장은 더 많은 토큰**이 소요됨
  
  → 한글은 다양한 조합형 문자 구조 때문

- **최대 입력 토큰 제한**
  
  → LLM 모델마다 입력 가능한 토큰 수가 제한됨

- **토큰 수 확인**
  
  → [`OpenAI Tokenizer`](https://platform.openai.com/tokenizer) 페이지 활용

---

### 🔸 OpenAI API 주요 파라미터

### ✅ 필수 파라미터

- `model`: 사용할 GPT 모델명 (예: `gpt-4o-mini`)
- `messages`: 대화 메시지 이력

### ✅ 응답 다양성 제어

- `temperature`
  
  → 다음 토큰 예측의 **다양성/창의성 조절** (0~2)
  
  → 값이 높을수록 다양한 결과, 낮을수록 일관된 결과

- `top_p`
  
  → 확률 누적합 기준으로 선택할 토큰 범위를 제한 (0~1)
  
  → 확률 높은 토큰만 집중

---

## 🔥 temperature 자세히 이해하기

### (1/2) 개념 정리

- **확률 분포를 날카롭거나 평탄하게 만듦**
- 높을수록 다양한 응답, 낮을수록 안정적/일관된 응답
- 모든 단어의 선택 확률을 조정해 다양성 통제 가능

---

### (2/2) 예시 비교

| 질문: "점심 뭐 먹을까?" → 후보 단어 확률 비교 |

| 단어   | 원래 확률 | temp=0.5 | temp=1.5 |
| ---- | ----- | -------- | -------- |
| 김치찌개 | 0.5   | 0.8      | 0.4      |
| 된장찌개 | 0.3   | 0.2      | 0.3      |
| 라면   | 0.15  | 0.02     | 0.2      |
| 초밥   | 0.05  | 0.01     | 0.1      |

- 🔵 **낮은 temperature (0.5)**
  
  → 높은 확률 단어(김치찌개)가 더 강화되어 **일관된 응답 생성**

- 🔴 **높은 temperature (1.5)**
  
  → 분포가 평탄화되어 **다양한 단어 선택 가능성 증가**

## Single turn 대화

```bash
#Single-turn 대화 : 한 번의 질문과 한 번의 응답으로 이루어진 대화 형태 (이전 대화 내용 기억 못함)
from openai import OpenAI
client = OpenAI(api_key=OPENAI_API_KEY)

# '종료' 입력 전까지 대화
user_input = ''
while True:
    user_input = input("You: ")
    if "종료" in user_input : break
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": user_input}],
        temperature=1.0,  # 확률 분포 조정을 통한 응답의 다양성 제어 (값의 범위: 0~2)
        top_p=0.5,  # 누적 확률 값을 통한 응답의 다양성 제어 (값의 범위: 0~1)
        max_tokens=500,# 생성될 응답의 최대 토큰 수
    )

    assistant_reply = response.choices[0].message.content
    print(f"Assistant: {assistant_reply}")
```

## Multi turn 대화

```bash
#페르소나 지정 예시 코드
from openai import OpenAI
client = OpenAI(api_key=OPENAI_API_KEY)

conversation_history = [
{"role": "system",
"content":
'''
<페르소나>
# 역할
- 당신의 이름은 '김초롱 '입니다.
- 당신은 과학적인 질문에 재치 있게 답하는 천재 물리학자의 역할을 수행해야 합니다.
 '''
}]

# '종료' 입력 전까지 대화
user_input = ''
while True:
    user_input = input("You: ")
    if "종료" in user_input : break
    conversation_history.append({"role": "user", "content": user_input})

    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=conversation_history,
        max_tokens=500,# 생성될 응답의 최대 토큰 수,
    )

    assistant_reply = response.choices[0].message.content
    conversation_history.append({"role": "assistant", "content": assistant_reply})

    print(f"Assistant: {assistant_reply}")
```

[Google Colab](https://colab.research.google.com/drive/1JBpH6CIHJPEL_N6mA9LaA-Jk3lCjA0Rh#scrollTo=Hzwi4lEJFyID)

---

# Vibe Coding

## ✅ 1. Vibe Coding이란?

- **코딩 지식 없이도** 자연어로 개발 가능한 방식
- “로그인 기능 만들어줘” → AI가 코드 자동 생성
- **비전공자도 빠르게 개발에 참여 가능**
- 아이디어만 있으면 구현 가능한 환경 제공

---

## ✅ 2. 주요 장점

- 🧩 **비전공자 접근성**: 문법·에러 몰라도 시작 가능
- 🚀 **빠른 MVP 개발**: 기획 → 구현까지 시간 단축
- 🤝 **협업 효율화**: 기획자가 직접 프로토타입 구현
- 🌐 **다양한 언어 지원**: Python, JS, HTML 등

---

## ✅ 3. 실습 도구

| 도구               | 설명                   |
| ---------------- | -------------------- |
| **VSCode**       | 기본 에디터 및 명령어 실행 환경   |
| **Cursor AI**    | 자연어 기반 AI 코딩 툴       |
| **웹 브라우저**       | 결과물 실행·확인 용도         |
| **Notion / Git** | 문서 정리 / 버전 관리용 필수 도구 |

---

## ✅ 4. 코딩 흐름: **정의 → 요청 → 생성 → 테스트 → 반복**

### 🧭 1) 문제 정의

- 만들고자 하는 기능을 구체적으로 설명
  - ❌ “로그인 기능”
  - ✅ “이메일/비번 입력창 + 로그인 버튼 + 환영 메시지”

### 💬 2) 프롬프트 작성

- **구체적이고 명확하게**
  - ✅ 행동 동사 사용: “출력해줘”, “반응형으로 보여줘”
  - ✅ 기술 스택 지정: “HTML만 사용해줘”
  - ✅ 조건 명시: “버튼은 파란색으로 해줘”

### ⚙️ 3) 코드 생성

- AI가 학습된 패턴으로 코드 구성
- 요구가 불명확하면 의도와 다른 코드가 생성될 수 있음

### 🧪 4) 실행 및 테스트

- 기본 동작, 입력 값 처리, 콘솔 로그 점검
- 빈칸, 예외 입력 등 다양한 시나리오 테스트 필요

### 🔁 5) 수정 및 반복

- 위치, 스타일, 기능 추가/삭제 등 자연어로 요청
  - “버튼 오른쪽 아래로 옮겨줘”
  - “React 없이 다시 만들어줘”
- 복잡한 수정은 **작은 단위로 쪼개서 반복**

---

## ⚠️ 유의사항 & 실수 방지 팁

- 📌 **요구는 구체적으로!**
- 🚫 **개인정보/민감 정보 절대 입력 금지**
- 🧠 **기초 개념(프론트/백, DB, API 등)은 알고 있으면 좋음**
- ✍️ **프롬프트 연습 = 결과 품질 향상**

---

## 🧩 실전 팁

- 🔹 **작게 나눠 요청**: 로그인 → 다음 기능 순차적으로
- 📸 **예시 포함**: 원하는 UI나 기능 흐름 설명 시 명확해짐
- 💾 **자주 저장**: GitHub/Notion 활용
- 🧠 **검색 + 질문 습관화**: 커뮤니티, 영상, 포럼 적극 활용
- 🧱 **작은 성공 → 확장 전략**

---

# 느낀점 및 후기

- 생각보다 copilot을 통한 바이브 코딩이 잘 작동했다.

- 본인은 python을 주로 하였고, js와 css, html은 간단한 정도로 해석이 가능한 수준인데 이렇게 간단하게 웹앱을 만들 수 있다는 것이 신기했다.

- 다만, 그럼에도 불구하고 오류가 나는 경우가 있었다.
  
  - api key가 제대로 입력되지 않은 경우처럼 간단한 오류부터,
  - 보안 향상을 위해 .env 및 secret.js 파일을 생성하면서 제대로 연동되지 않는, 지금 내가 직접 코드를 읽어도 해결할 수 없는 수준의 복잡한 오류까지 있었다.
  - 이 오류가 자연어 명령 혹은 나의 직접 수정으로 해결이 가능한 수준인지 아닌지를 판별할 수 있는 능력이 필요하다고 느꼈다.
  
  → 따라서 바이브 코딩을 하는 사람에게도 기본적인 코드 해석 능력은 필요하다는 생각이 들었다.

- 근데 이걸 계속 쓰다보면 코딩 실력이 늘기는 힘들 것 같다는 생각이 든다..
